{"mappings":"AAAA,MAAM;IACF,aAAc,CAEd;IAEA,IAAI,WAAW;QACX,OAAO,IAAI,CAAC;IAChB;IAEA,IAAI,UAAU;QACV,OAAO,IAAI,CAAC;IAChB;IAEA,IAAI,UAAU;QACV,OAAO,IAAI,CAAC;IAChB;IAEA,MAAM,KAAK,GAAG,EAAE;QACZ,MAAM,UAAU,MAAM,SAAS;QAE/B,uCAAuC;QACvC,iCAAiC;QACjC,sBAAsB;QAEtB,IAAI,OAAO,IAAI,IAAI,KAAK;QAExB,IAAI,CAAC,YAAY,KAAK;QACtB,IAAI,CAAC,WAAW,KAAK;QACrB,IAAI,CAAC,WAAW,KAAK;IAErB,8BAA8B;IAC9B,6BAA6B;IAC7B,6BAA6B;IAC7B,oBAAoB;IAEpB,mBAAmB;IACnB,0BAA0B;IAC1B,uBAAuB;IAC3B;IAEA,OAAO,IAAI,EAAE;QACT,MAAM,QAAQ,KAAK,MAAM;QACzB,MAAM,QAAQ,CAAA;YACV,OAAO,KAAK,OAAQ,8CAA8C;;YAClE,IAAI,SAAS,MAAM,KAAK,WAAW,MAC/B;YAGJ,IAAI,KAAK,WAAW,OAAO;gBACvB,MAAM,SAAS,KAAK,MAAM,KAAK,CAAC,EAAE,CAAC,MAAM,KAAK,0BAA0B;;YACxE,2BAA2B;YAC/B,OAAO,IAAI,KAAK,WAAW,OAAO;gBAC9B,MAAM,SAAS,KAAK,MAAM,MAAM,CAAC,EAAE,CAAC,MAAM,KAAK,2BAA2B;;YAC1E,4BAA4B;YAChC,OAAO,IAAI,KAAK,WAAW,OAAO;gBAC9B,MAAM,SAAS,KAAK,MAAM,MAAM,CAAC,EAAE,CAAC,MAAM,KAAK,2BAA2B;;YAC1E,4BAA4B;YAChC,OAAO,IAAI,KAAK,WAAW,OAAO;gBAC9B,MAAM,SAAS,KAAK,MAAM,KAAK,CAAC,EAAE,CAAC,MAAM,KAAK,2BAA2B;;gBACzE,QAAQ,IAAI,KAAK;YACrB;QAEJ;IACJ;IAEA,UAAU,IAAI,EAAE;QAEZ,MAAM,WAAW,CACjB;QAEA,MAAM,YAAY;QAClB,MAAM,QAAQ,KAAK,MAAM;QACzB,IAAK,IAAI,SAAS,GAAG,SAAS,MAAM,QAAQ,EAAE,OAAQ;YACpD,MAAM,OAAO,KAAK,CAAC,OAAO,CAAC;YAC3B,IAAI,SAAS,MAAM,KAAK,WAAW,MACjC;YAEF,MAAM,IAAI,UAAU,KAAK;YACzB,IAAI,CAAC,GACH;YAEF,MAAM,GAAG,SAAS,aAAa,GAAG;YAClC,MAAM,QAAQ,KAAK,MAAM,OAAO,MAAM;YACtC,MAAM,UAAU,QAAQ,CAAC,QAAQ;YACjC,IAAI,CAAC,SAAS;gBACZ,QAAQ,KAAK,sBAAsB,SAAS,WAAW,SAAS;gBAChE;YACF;YACA,QAAQ,OAAO;QACjB;IACF;AACN","sources":["src/LabaCore/src/Engine/OBJLoader.js"],"sourcesContent":["class OBJLoader {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    get vertices() {\r\n        return this._vertices\r\n    }\r\n\r\n    get normals() {\r\n        return this._normals\r\n    }\r\n\r\n    get indices() {\r\n        return this._indices\r\n    }\r\n\r\n    async load(url) {\r\n        const objText = await loadFile(url)\r\n\r\n        // const objFile = new OBJFile(objText)\r\n        // const output = objFile.parse()\r\n        // console.log(output)\r\n\r\n        var mesh = new OBJ.Mesh(objText)\r\n\r\n        this._vertices = mesh.vertices\r\n        this._normals = mesh.vertexNormals\r\n        this._indices = mesh.indices\r\n\r\n        // console.log(this._vertices)\r\n        // console.log(this._normals)\r\n        // console.log(this._indices)\r\n        // console.log(mesh)\r\n\r\n        // console.log(obj)\r\n        // this._parseOBJ(objText)\r\n        // this._parse(objText)\r\n    }\r\n\r\n    _parse(text) {\r\n        const lines = text.split('\\n')\r\n        lines.forEach(line => {\r\n            line = line.trim()  // удалить начальные и конечные пробелы строки\r\n            if (line === \"\" || line.startsWith(\"#\")) {\r\n                return\r\n            }\r\n\r\n            if (line.startsWith(\"v \")) {\r\n                const values = line.split(\"v \")[1].split(\" \") // все значения после \"v \"\r\n                // console.log(\"v\", values)\r\n            } else if (line.startsWith(\"vt\")) {\r\n                const values = line.split(\"vt \")[1].split(\" \") // все значения после \"vt \"\r\n                // console.log(\"vt\", values)\r\n            } else if (line.startsWith(\"vn\")) {\r\n                const values = line.split(\"vn \")[1].split(\" \") // все значения после \"vn \"\r\n                // console.log(\"vn\", values)\r\n            } else if (line.startsWith(\"f \")) {\r\n                const values = line.split(\"f \")[1].split(\" \") // все значения после \"f \"\\\r\n                console.log(\"f\", values)\r\n            }\r\n            \r\n        })\r\n    }\r\n\r\n    _parseOBJ(text) {\r\n \r\n        const keywords = {\r\n        };\r\n       \r\n        const keywordRE = /(\\w*)(?: )*(.*)/;\r\n        const lines = text.split('\\n');\r\n        for (let lineNo = 0; lineNo < lines.length; ++lineNo) {\r\n          const line = lines[lineNo].trim();\r\n          if (line === '' || line.startsWith('#')) {\r\n            continue;\r\n          }\r\n          const m = keywordRE.exec(line);\r\n          if (!m) {\r\n            continue;\r\n          }\r\n          const [, keyword, unparsedArgs] = m;\r\n          const parts = line.split(/\\s+/).slice(1);\r\n          const handler = keywords[keyword];\r\n          if (!handler) {\r\n            console.warn('unhandled keyword:', keyword, 'at line', lineNo + 1);\r\n            continue;\r\n          }\r\n          handler(parts, unparsedArgs);\r\n        }\r\n      }\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"version":3,"file":"index.3faaf029.js.map","sourceRoot":"/__parcel_source_root/"}